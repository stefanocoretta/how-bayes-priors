<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>How to Bayes: Priors</title>
    <meta charset="utf-8" />
    <meta name="author" content="Stefano Coretta" />
    <meta name="date" content="2022-05-12" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link rel="stylesheet" href="libs/ipa-fonts.css" type="text/css" />
    <link rel="stylesheet" href="libs/custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# How to Bayes: Priors
]
.author[
### Stefano Coretta
]
.institute[
### UoE LEL
]
.date[
### 2022-05-12
]

---







class: middle

.pull-left[
![](img/06-rainy-umbrella-humid.svg)
]

.pull-right[
![](img/01-sunny.svg)
]

???

We are faced every day with probabilities. Just think about the weather forecast.

We say things like "there is a 70% probability that it will rain today". In this sense, *probability* is the probability of an event occurring.

But what about more complex situations that are not a flip-of-coin kinda situation? For example what about rolling two dice?

Here is where probability distributions come in.

A probability distribution is a list of values and their corresponding probability.

---

# Discrete and continuous

&lt;br&gt;

.center[
![:scale 80%](img/discr-cont-probs.png)
]

???

Depending on the nature of the values a variable can take, there are 2 types of probs.

---

class: middle

&lt;iframe src="https://seeing-theory.brown.edu/probability-distributions/index.html#section2" style="border:none;" width="100%" height="100%"&gt;

???

But how do we describe probability distributions? We can't make a list of all values and probabilities, especially for continuous probabilities.

Instead, we specify the value of a few parameters that describe the distribution in a succinct way.

---

class: middle

&lt;span style="font-size:3em;"&gt;$$y_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

???

Let's look at some formulas.

This is the formula of a variable `\(y_1\)` that is distributed according to (~) a Gaussian probability distribution.

A Gaussian distribution can be described with two parameters: the mean and the standard deviation.

---

class: center middle

&lt;img src="index_files/figure-html/f0-prior-1.png" width="800px" height="500px" style="display: block; margin: auto;" /&gt;

---

class: middle

&lt;span style="font-size:3em;"&gt;$$\text{f0}_i \sim Gaussian(200, 50)$$&lt;/span&gt;

???

We can describe that distribution with this formula (much easier than listing all the values and their probability).

---

# Bayesian belief update

&lt;br&gt;

.center[
![:scale 60%](img/prior-update.png)
]

???

How do we ensure that prior knowledge is not lost?

You've seen in Session 01 that Bayesian analysis is about estimating the posterior probability distribution of a variable of interest.

Roughly speaking, the posterior probability distribution is the combination of the prior belief and the evidence derived from the data.

Prior and evidence are, of course, probability distributions.

---

class: middle

&lt;iframe src="https://seeing-theory.brown.edu/bayesian-inference/index.html#section3" style="border:none;" width="100%" height="100%"&gt;

---

# Prior belief as probability distributions

&amp;nbsp;

&lt;span style="font-size:1.5em;"&gt;$$\text{RT}_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

???

Our prior belief about RTs is that they are distributed according to a Gaussian (aka Gaussian) distribution.

The Gaussian distribution has two parameters: mean `\(\mu\)` and standard deviation `\(\sigma\)`.

Now, we want to estimate these two parameters from the data.

---

# Prior belief as probability distributions

&amp;nbsp;

**Reaction Times** from a lexical decision task.

&lt;br&gt;

&lt;span style="font-size:1.5em;"&gt;$$\text{RT}_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

&lt;span style="font-size:1.5em;"&gt;$$\mu = ...?$$&lt;/span&gt;

???

We do have an idea of what the mean RT could be like but we are not certain.

When you are not certain, you make a list of values and their probability, i.e. a probability distribution!

https://app.sli.do/event/5yqqvpyDeaTeRDg2Faojay

---

# Prior belief as probability distributions

&amp;nbsp;

**Reaction Times** from a lexical decision task.

&lt;br&gt;


&lt;span style="font-size:1.5em;"&gt;$$\text{RT}_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

&lt;span style="font-size:1.5em;"&gt;$$\mu \sim Gaussian(\mu_1, \sigma_1)$$&lt;/span&gt;

???

Usually, we assume the mean `\(\mu\)` to be a value taken from another Gaussian distribution (with its own mean and SD).

This Gaussian distribution is the **prior probability distribution** (or simply prior) of the mean.

---

# Prior belief as probability distributions

&amp;nbsp;

**Reaction Times** from a lexical decision task.

&lt;br&gt;


&lt;span style="font-size:1.5em;"&gt;$$\text{RT}_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

&lt;span style="font-size:1.5em;"&gt;$$\mu \sim Gaussian(0, \sigma_1)$$&lt;/span&gt;

???

We will talk about different types of priors later. For now it's sufficient to remember that a conservative approach (which is what we want to do) is to set `\(\mu_1\)` to 0.

--

&lt;br&gt;
&lt;br&gt;

**What about `\(\sigma_1\)`?**

???

What about `\(\sigma_1\)`?

---

# The empirical rule


&lt;img src="index_files/figure-html/empirical-rule-1.png" width="800px" height="500px" style="display: block; margin: auto;" /&gt;

???

As a general rule, `\(\pm2\sigma_1\)` covers 95% of the Gaussian distribution, which means we are 95% confident that the value lies within that range.

Let's be generous and assume that the mean RT will definitely not be greater than 3 seconds. (This might seem like a very high number, but we will see how it can help estimation)

3000/2 = 1500 ms (remember, two times the SD), so we can set `\(\sigma_1 = 1500\)`.

---

# Seeing is believing

&lt;img src="index_files/figure-html/prior-1-1.png" width="800px" height="500px" style="display: block; margin: auto;" /&gt;

???

Visualising priors is important, because it's easier to grasp their meaning when you can actually see the shape of the distribution.

Are you wondering about the negative values? (RT cannot be negative!) I will tell more about this and how to "fix" it later.

---

# Prior belief as probability distributions

&amp;nbsp;

**Reaction Times** from a lexical decision task.

&lt;br&gt;


&lt;span style="font-size:1.5em;"&gt;$$\text{RT}_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

&lt;span style="font-size:1.5em;"&gt;$$\mu \sim Gaussian(0, 1500)$$&lt;/span&gt;

---

# Get the default priors

&lt;br&gt;


```r
get_prior(
  RT ~ 1,
  data = mald,
  family = gaussian
)
```

```
##                     prior     class coef group resp dpar nlpar lb ub  source
##  student_t(3, 952, 220.9) Intercept                                  default
##    student_t(3, 0, 220.9)     sigma                             0    default
```

---

# Set your priors

&lt;br&gt;


```r
my_priors &lt;- c(
  prior(...), # Intercept
  prior(...)  # sigma
)
```

---

# Set your priors

&lt;br&gt;


```r
my_priors &lt;- c(
  prior(normal(0, 1500), class = Intercept), # Intercept
  prior(...)  # sigma
)
```

---

# What about `\(\sigma\)`?

&lt;br&gt;
&lt;br&gt;

&lt;span style="font-size:1.5em;"&gt;$$\text{RT}_i \sim Gaussian(\mu, \sigma)$$&lt;/span&gt;

&lt;span style="font-size:1.5em;"&gt;$$\mu \sim Gaussian(0, 1500)$$&lt;/span&gt;

&lt;span style="font-size:1.5em;"&gt;$$\sigma = ...?$$&lt;/span&gt;

???

Now, what about `\(\sigma\)`? (Be careful not to mix up `\(\sigma\)` and `\(\sigma_1\)`! This is `\(\sigma\)` from the first line, not `\(\sigma_1\)` from the second line).

---

# Prior for `\(\sigma\)`: Half Cauchy

&lt;br&gt;

&lt;img src="index_files/figure-html/cauchy-1.png" height="500px" style="display: block; margin: auto;" /&gt;

???


```r
HDInterval::inverseCDF(
  c(0.5, 0.75, 0.95),
  phcauchy,
  sigma = 100
)
```

```
## [1]  100.0000  241.4214 1270.6205
```


---

class: inverse center bottom
background-image: url("img/chris-robert-unsplash.jpg")

# BREAK

---

class: inverse center middle
background-image: url("img/code-matrix.jpg")

# &lt;span style="font-size:1.5em;"&gt;LIVE CODING&lt;/span&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="libs/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "agate",
"highlightLanguage": "r",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
